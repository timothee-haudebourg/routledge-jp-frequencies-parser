#!/usr/bin/env ruby
require 'romaji'
require 'json'

# Part of speech
POS = [
	'adn.', # adnominal
	'adv.', # adverb
	'aux.', # auxiliary
	'conj.', # conjunction
	'cp.', # compound
	'i-adj.', # i-adjectif
	'interj.', # interjection
	'n.', # noun
	'na-adj.', # na-adjectif 
	'num.', # numeral
	'p.', # particle
	'p.case', # case particle
	'p.conj.', # conjunctive particle
	'p.disc.', # discourse particle
	'prefix', # prefix
	'pron.', # pronoun
	'suffix', # suffix
	'v.'  # verb
]

def to_katakana(str)
	Romaji.romaji2kana(str.gsub(' ', ''))
end

class Array
	def as_json
		self.map { |e| e.as_json }
	end
end

class Definition
	attr_reader :pos
	attr_reader :definitions

	def initialize(pos)
		@pos = pos
		@definitions = []
	end
end

class Header
	attr_reader :pronunciations
	attr_reader :definitions

	def initialize(pronunciations, definitions)
		@pronunciations = pronunciations
		@definitions = definitions
	end
end

class Entry
	def initialize(index, lemma, forms, freq, dispersion, samples)
		if lemma[0].include?('（お）') then
			STDERR.puts ("INDEX:"+index.to_s)
			lemma[0] = lemma[0].sub('（お）', '')
			lemma << 'お'+lemma[0]
		end
	
		@index = index
		@lemma = lemma
		@forms = forms
		@frequency = freq
		@dispersion = dispersion
		@samples = samples
	end
	
	def as_json()
		{
			index: @index,
			lemma: @lemma,
			forms: @forms.as_json,
			frequency: @frequency,
			dispersion: @dispersion,
			samples: @samples
		}
	end
end

class Writing
	attr_accessor :writing
	attr_accessor :readings

	def initialize(writing, readings)
		@writing = writing
		@readings = readings
	end
end

class Form
	attr_reader :writings
	attr_reader :definitions

	def initialize(writings, definitions)
		@writings = []
	
		writings.each do |w|
			@writings << w
			if w.writing.include?('（お）') then
				w.writing = w.writing.sub('（お）', '')
				w.readings.map!{ |r| r.sub('(o)-', '').sub('(o)', '') }
				@writings << Writing.new('お'+w.writing, w.readings.map{ |r| 'o'+r })
			end
		end

		@definitions = definitions
	end
	
	def as_json
		writings = {}
		@writings.each do |w|
			writings[w.writing] = w.readings
		end
		
		definitions = {}
		@definitions.each do |d|
			definitions[d.pos] = d.definitions
		end
	
		{
			writings: writings,
			definitions: definitions
		}
	end
end

# Parse a raw input and separate entries.
def string_entries(raw)
	lost_frequencies = []
	
	sections = raw.split("\n\n").select do |section|
		is_section = section.count('•') >= 2 && section.split[0].to_i != 0
		
		if !is_section && section.include?(' | 0.') && !section.include?("\n") then
			lost_frequencies << section
		end
		
		is_section
	end

	lost_frequencies.sort! { |a, b| a[/[0-9]+/].to_i <=> b[/[0-9]+/].to_i }
	entries = []

	sections.each do |section|
		n = section[/[0-9]+/].to_i
		entries[n-1] = section
	end

	entries.each.with_index do |d, i|
		if !d.include?(' | ') then
			f = lost_frequencies.pop
			d << "\n" + f
		end
	end

	return entries
end

def is_number(c)
	c == "0" || c.to_i != 0
end

def fix_ambiguities(str)
	str.sub('p. case', 'p.case')
	   .sub('p. conj.', 'p.conj.')
	   .sub('p. disc.', 'p.disc.')
	   .gsub(',', ' , ').gsub(';', ' ; ')
end

def parse_header(n, str)
	state = :pronunciation
	
	pronunciations = []
	forms = []
	
	current_pronunciation = ''
	current_form = nil
	current_definition = ''
	
	str.sub!(' adv ', ' adv. ') # if n == 2629 # EXCEPTION
	str.sub!(' n ', ' n. ') if n == 4966 # EXCEPTION
	str.sub!(' na-adj ', ' na-adj. ')

	fix_ambiguities(str).split.each do |word|
		if !word.strip.empty? then
			case state
			when :pronunciation then
				if POS.include?(word) then
					current_pronunciation.strip!
					pronunciations << current_pronunciation unless current_pronunciation.empty?
					current_pronunciation = ''
					
					current_form = Definition.new(word)
					state = :definition
				elsif word == ','
					current_pronunciation.strip!
					pronunciations << current_pronunciation unless current_pronunciation.empty?
					current_pronunciation = ''
				else
					current_pronunciation += ' '+word
				end
			else
				if POS.include?(word) then
					current_definition.strip!
					current_form.definitions << current_definition unless current_definition.empty?
					current_definition = ''
					
					forms << current_form
					current_form = Definition.new(word)
				elsif word == ',' && current_definition.empty? 
					# skip it
				elsif word == ';'
					current_definition.strip!
					current_form.definitions << current_definition unless current_definition.empty?
					current_definition = ''
				else
					current_definition += ' '+word
				end
			end
		end
	end
	
	current_definition.strip!
	current_form.definitions << current_definition unless current_definition.empty?
	forms << current_form unless current_form.nil?
	
	if forms.empty? then
		STDERR.puts "invalid header for #{n}"
		STDERR.puts str
		exit 1
	end
	
	# STDERR.puts "maybe secondary pos in #{n}: #{forms}" if forms.join(',').include?('.')
	
	Header.new(pronunciations, forms)
end

def is_romaji(c)
	i = c.ord
	return (i >= 0x61 && i <= 0x7a)
end

# Parse a string entry into actual entry.
def string_to_entry(str)
	state = :index
	
	last_non_space = nil
	
	index = ""
	vocab = ""
	header = ""
	sample_jp = ""
	sample_en = ""
	freq = ""
	dispersion = ""
	source = ""
	
	samples = []
	
	str.gsub('.”', '”.').split('').each do |c|
		c = " " if c == "\n"
		case state
		when :index
			if c == ' ' then
				state = :vocab unless index.empty?
			else
				index << c
			end
		when :vocab
			if is_romaji(c) || (c == '(' && (vocab[-1] == ' ' || vocab[-1] == '）')) then
				state = :header unless vocab.empty?
				header << c
			else
				vocab << c
			end
			last_non_space = c unless c == " "
		when :header
			if c == '•' then
				state = :sample_jp
			else
				header << c
			end
		when :sample_jp
			if c == '—' then
				state = :sample_en
			else
				sample_jp << c unless c == "•"
			end
		when :sample_en
			if c == "•" then
				samples << {jp: sample_jp, en: sample_en}
				sample_jp = ""
				sample_en = ""
				last_non_space = nil
				state = :sample_jp
			elsif is_number(c) && (last_non_space == "." || last_non_space == "!" || last_non_space == "?") then
				samples << {jp: sample_jp, en: sample_en}
				state = :freq
				freq << c
			else
				sample_en << c
				last_non_space = c unless c == " "
			end
		when :freq
			if c == '|' then
				state = :dispersion
			else
				freq << c
			end
		when :dispersion
			if c == '|' then
				state = :source
			else
				dispersion << c
			end
		else
			source << c
		end
	end
	
	index = index.to_i
	lemma = vocab.gsub('，', ',').split(',').map{ |l| l.strip }
	header = parse_header(index, header)
	
	
	writings = []
	if lemma.size == header.pronunciations.size then
		writings = lemma.map.with_index do |l, i|
			Writing.new(l, [header.pronunciations[i]])
		end
	else
		if lemma.size == 1 || header.pronunciations.size == 1 then
			writings = lemma.map.with_index do |l, i|
				Writing.new(l, header.pronunciations)
			end
		else
			# EXCEPTIONS
			if index == 16 then
				writings = [
					Writing.new(lemma[0], header.pronunciations[0..1]),
					Writing.new(lemma[1], [header.pronunciations[2]])
				]
			elsif index == 21 then
				writings = [
					Writing.new(lemma[0], [header.pronunciations[0]]),
					Writing.new(lemma[1], [header.pronunciations[1]]),
					Writing.new(lemma[2], [header.pronunciations[1]])
				]
			else
				STDERR.puts "unable to match a form to its pronunciations!"
				exit 1
			end
		end
	end
	
	forms = [Form.new(writings, header.definitions)]
	
	entry = Entry.new(index, lemma, forms, freq.to_i, dispersion.to_f, samples)
	
	if lemma[0].include?('（') || lemma[0].include?('（') then
		if lemma[0].include?('（する）') then
			if lemma.size == 1 then
				if header.pronunciations[0].include?('(suru)') then
					#
				else
					STDERR.puts JSON.pretty_generate(entry.as_json)
				end
			else
				STDERR.puts JSON.pretty_generate(entry.as_json)
			end
		else
			STDERR.puts JSON.pretty_generate(entry.as_json)
		end
	end
	
	if header.definitions.size > 1 && lemma.size > 1 then
		STDERR.puts JSON.pretty_generate(entry.as_json)
	end
	
	return entry
end

entries = string_entries(STDIN.read)

entries = entries.map do |d|
	string_to_entry(d)
end

puts JSON.pretty_generate(entries.map { |d| d.as_json })
